import * as aws from "@pulumi/aws";
import * as pulumi from "@pulumi/pulumi";

const webAppConfig=  new pulumi.Config("webApp");

// Create a new VPC
const vpc = new aws.ec2.Vpc("webappVPC", {
  cidrBlock:webAppConfig.get("cidrBlock") ,
});
console.log (vpc.id)
// Variable to hold subnet details

aws.getAvailabilityZones({ state: "available" }).then((response) => {
  const subnetDetails = [];
console.log(response.names)
  if (response.names.length > 2){
console.log (vpc.id) 
    const zones = response.names.slice(0, 3);

    let priv_zone = true;

    for (let i = 0; i < 6; i++) {
        const subnet = new aws.ec2.Subnet(`subnet${i}`, {
        vpcId: vpc.id,
        cidrBlock: `10.0.${i}.0/24`,
        availabilityZone: `${zones[Math.floor(i / 2)]}`,
        tags: {
            Name: `webapp-subnet${i}`,
            Type: priv_zone ? "public" : "private",
        },
    
        });
        priv_zone=!priv_zone;
        subnetDetails.push(subnet);
    }

  }else{
    const zones = response.names.slice(0, 2);
    for(let i = 0; i < 4; i++) {
        const subnet = new aws.ec2.Subnet(`subnet${i}`, {
        vpcId: vpc.id,
        cidrBlock: `10.0.${i}.0/24`,
        availabilityZone: `${ i < 2 ? zones[0]: zones[1]}`,
        tags: {
            Name: `webapp-subnet${i}`,
            Type: [0,2].includes(i) ? "public" : "private",
        },
    
        });
        
        subnetDetails.push(subnet);
    }

  }
  

  // Create an Internet Gateway and attach it to the VPC
  const ig = new aws.ec2.InternetGateway("webapp-ig", {
    vpcId: vpc.id,
  });

  // Create the public route table
  const publicRouteTable = new aws.ec2.RouteTable("webapp-publicRouteTable", {
    vpcId: vpc.id,
  });

  // Create the private route table
  const privateRouteTable = new aws.ec2.RouteTable("webapp-privateRouteTable", {
    vpcId: vpc.id,
  });

  // Loop through the created subnets and add the public ones to the public route table and private ones to the private route table
  for (let i = 0; i < subnetDetails.length; i++) {
    const routeTableAssociation = new aws.ec2.RouteTableAssociation(
      `webapp-routeTableAssociation${i}`,
      {
        subnetId: subnetDetails[i].id,
        routeTableId: i %2 == 0 ? publicRouteTable.id : privateRouteTable.id,
      }
    );
  }

  // Create a public route
  const publicRoute = new aws.ec2.Route("webapp-publicRoute", {
    routeTableId: publicRouteTable.id,
    destinationCidrBlock: webAppConfig.get("destinationCidrBlock"),
    gatewayId: ig.id,
  });

  const Ec2SecurityGroup= new aws.ec2.SecurityGroup("webAppSecurityGroup",{
    vpcId:vpc.id,
    ingress:[
      {
        protocol: "tcp",
        fromPort: 3000, // for web application port
        toPort: 3000,
        cidrBlocks: ["0.0.0.0/0"],
      },
      {
        protocol: "tcp", // for ssh
        fromPort: 22,
        toPort: 22,
        cidrBlocks: ["0.0.0.0/0"],
      },
      {
        protocol: "tcp",
        fromPort: 80, // for http traffic
        toPort: 80,
        cidrBlocks: ["0.0.0.0/0"],
      },
      {
        protocol: "tcp",
        fromPort: 443, // for https traffic
        toPort: 443,
        cidrBlocks: ["0.0.0.0/0"],
      },
    ]
  });


  const applicationEc2Instance= new aws.ec2.Instance("appEC2Instance",{
    instanceType: "t2.micro", // creating the ec2 instance
    vpcSecurityGroupIds: [Ec2SecurityGroup.id],
    ami: "ami-0df100c64b95ddaf4", // ID generated by the github action
    subnetId: subnetDetails[0].id, // Choosing the first subnet for the instance
    associatePublicIpAddress: true,
    rootBlockDevice: {
      volumeSize: 25,
      volumeType: "gp2",
      deleteOnTermination: true,
    },
  
    keyName: webAppConfig.get("keyPairName"),
    disableApiTermination: false,
    tags: {
      Name: "app-instance",
    },
  })


});

// Create 3 public and 3 private subnets

// Export VPC ID
export const vpcId = vpc.id;
